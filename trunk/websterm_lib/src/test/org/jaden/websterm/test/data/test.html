<html>
<head>
<title>A test HTML Document</title>
</head>
<body>
<h1>This is a test HTML Document</h1>
<p>We create a new Event object, and hand it over to Hibernate.
Hibernate now takes care of the SQL and executes INSERTs on the
database. Let's have a look at the Session and Transaction-handling code
before we run this. A Session is a single unit of work. For now we'll
keep things simple and assume a one-to-one granularity between a
Hibernate Session and a database transaction. To shield our code from
the actual underlying transaction system (in this case plain JDBC, but
it could also run with JTA) we use the Transaction API that is available
on the Hibernate Session. What does sessionFactory.getCurrentSession()
do? First, you can call it as many times and anywhere you like, once you
get hold of your SessionFactory (easy thanks to HibernateUtil). The
getCurrentSession() method always returns the "current" unit of work.
Remember that we switched the configuration option for this mechanism to
"thread" in hibernate.cfg.xml? Hence, the current unit of work is bound
to the current Java thread that executes our application. However, this
is not the full picture, you also have to consider scope, when a unit of
work begins and when it ends. A Session begins when it is first needed,
when the first call to getCurrentSession() is made. It is then bound by
Hibernate to the current thread. When the transaction ends, either
through commit or rollback, Hibernate automatically unbinds the Session
from the thread and closes it for you. If you call getCurrentSession()
again, you get a new Session and can start a new unit of work. This
thread-bound programming model is the most popular way of using
Hibernate, as it allows flexible layering of your code (transaction
demarcation code can be separated from data access code, we'll do this
later in this tutorial). Related to the unit of work scope, should the
Hibernate Session be used to execute one or several database operations?
The above example uses one Session for one operation. This is pure
coincidence, the example is just not complex enough to show any other
approach. The scope of a Hibernate Session is flexible but you should
never design your application to use a new Hibernate Session for every
database operation. So even if you see it a few more times in the
following (very trivial) examples, consider session-per-operation an
anti-pattern. A real (web) application is shown later in this tutorial.

Have a look at Chapter 11, Transactions And Concurrency for more
information about transaction handling and demarcation. We also skipped
any error handling and rollback in the previous example. To run this
first routine we have to add a callable target to the Ant build file:</p>
</body>
</html>
